# Application v0.x-alpha Overview

This document outlines the planned features and scope for the `v0.x-alpha` release of Internara. This release represents the foundational, initial development phase of the application, focusing on establishing core architectural components, essential modules, and basic functionalities. Each feature described below is conceived as a distinct, modular unit with a clear and limited scope, designed for independent development and integration. At this stage, the features are defined but not yet fully implemented or publicly released.

---

## Core Feature Units

### 1. Application Auto Binding: Service Binding and Discovery (`app/Providers`)
*   **Scope:** Implements a robust service binding and auto-discovery mechanism, primarily managed through `app/Providers/BindServiceProvider`. Key aspects include:
    *   Automated resolution of interfaces to concrete implementations based on naming conventions.
    *   Support for caching discovery results for performance.
    *   Configurable patterns for guessing implementations.
    *   Support for explicit manual and contextual bindings.
    This mechanism aims to streamline dependency injection across the application, ensuring a flexible and maintainable architecture.
*   **Implementation:** The `BindServiceProvider` dynamically scans predefined directories (e.g., `App/Contracts`, `Modules/*/src/Contracts`) for PHP interfaces. For each found interface, it attempts to "guess" a corresponding concrete implementation based on configurable naming patterns (e.g., an `AuthServiceContract` would look for `AuthService`). These interfaces and their concrete classes are then registered with Laravel's service container, allowing for automatic dependency injection throughout the application. Caching mechanisms are employed to optimize performance by storing discovered bindings.

### 2. Foundational Modular Structure: Core, Support, and Shared Modules
*   **Scope:** Establishes the foundational modular structure of the application. This includes:
    *   **`Core` module:** Encapsulates the essential architectural building blocks and business rules specific to the Internara business domain.
    *   **`Shared` module:** Provides universal, portable components completely agnostic of Internara's specific business rules.
    *   **`Support` module:** Handles specialized integrations and abstracts infrastructure-level complexity for `Core` and domain modules.
    These modules define the base framework for future domain-specific modules and adhere to strict portability guidelines, promoting reusability and clear separation of concerns.
*   **Implementation:** The `nwidart/laravel-modules` package is central to this structure. Each module, including `Core`, `Support`, and `Shared`, resides as a distinct directory under `modules/`, complete with its own `module.json` manifest, `src/` folder for code, `database/` for migrations/seeders, `resources/` for views/assets, and `routes/`.
    *   **`Core` module:** Houses architectural patterns, base contracts, traits, and global services fundamental to Internara's operation. It defines the bedrock on which other domain-specific modules are built, containing logic that is essential across the entire application.
    *   **`Shared` module:** Contains truly generic, reusable components such as general utility classes, helper functions, and design patterns that are entirely decoupled from Internara's specific business domain. It aims for maximum portability and minimal dependencies, serving as a common toolkit.
    *   **`Support` module:** Abstracts external integrations (e.g., payment gateways, external APIs) or complex infrastructure concerns, providing simplified interfaces for the `Core` and other domain modules. This ensures that business logic remains clean and isolated from external system complexities.
    The modular approach enforces clear boundaries, making the application easier to understand, test, and maintain, and facilitates independent development of features.

### 3. Exception Management: Standardized Error Handling (`Exception` module)
*   **Scope:** Implements a standardized, localized exception handling system using a dedicated `Exception` module. This includes custom `AppException` (for all domain-specific or business logic errors) and `RecordNotFoundException` classes. The system ensures consistent, user-friendly error feedback and detailed, structured logging for developers, improving debugging and user experience.
*   **Implementation:** The `Exception` module contains `AppException.php` and `RecordNotFoundException.php`, both extending PHP's native `Exception`. `AppException` is the base for all domain-specific exceptions, providing crucial functionality: it allows for separate, localized user-friendly messages (`getUserMessage()`) and detailed technical log messages (`getLogMessage()`), and can carry additional context data (`getContext()`). Critically, it implements a `render(Request $request)` method. Laravel's default exception handler automatically invokes this method for any exception that defines it, enabling `AppException` to provide custom HTTP responses (e.g., JSON for API requests, redirect with messages for web requests). `RecordNotFoundException` extends `AppException`, specializing its behavior for 404 "not found" scenarios and enriching its context with details about the missing record.
    Complementing these classes is the `HandlesAppException` trait (`modules/Exception/src/Concerns/HandlesAppException.php`). This trait provides helper methods (e.g., `isAppException`, `newAppException`, `throwAppException`, `reportException`, `renderAppException`, `handleAppExceptionInLivewire`) that centralize common exception-related operations. It acts as a universal entry point (`handleAppException`) for intelligently managing exceptions based on the request context (web, API, Livewire), ensuring consistent reporting and appropriate responses throughout the application. This approach ensures consistent error presentation and robust debugging capabilities across the application.

### 4. Core UI System: Frontend Framework and Components (`UI` module)
*   **Scope:** Develops the foundational UI framework within a dedicated `UI` module. This encompasses:
    *   Setting up **Tailwind CSS**, **DaisyUI**, and **MaryUI** for consistent styling and component usage.
    *   Defining theming (light/dark mode support) and typography standards.
    *   Establishing core Blade and Livewire components that form the basis of the user interface.
    The `UI` module serves as the single source of truth for all frontend assets and standards, ensuring a cohesive and maintainable user interface.
*   **Implementation:** The `UI` module acts as a centralized repository for all frontend concerns. It includes configuration for Tailwind CSS, DaisyUI (a Tailwind component library), and MaryUI (a set of Livewire components designed for Admin panels). This ensures a consistent look and feel across the application. Core Blade layouts, components, and foundational Livewire components (e.g., modals, tables, forms) are defined here, which other modules can extend or utilize, promoting UI consistency and reusability.

### 5. Application Setups: Initial Deployment and Configuration (`Setup` module)
*   **Scope:** Provides initial setup mechanisms for the application. This includes:
    *   Automated database seeding for core roles and permissions.
    *   Basic configuration guided by environment variables (`.env`).
    This module facilitates the initial deployment and streamlines the configuration steps for new installations, ensuring a smooth onboarding process.
*   **Implementation:** The `Setup` module includes Artisan commands and database seeders specifically designed for initial application bootstrapping. These commands can automate tasks like creating the initial "Owner" user, assigning default roles and permissions, and setting up other essential application configurations based on environment variables. This minimizes manual intervention required after a fresh deployment, streamlining the setup process for developers and administrators.

### 6. Application Settings: Centralized Configuration Management (`Setting` module)
*   **Scope:** Implements a basic system for managing application-wide settings. This includes:
    *   A dedicated `Setting` model for persistence.
    *   A basic administrative interface for CRUD (Create, Read, Update, Delete) operations on these settings.
    This module allows key application parameters to be configured and managed centrally, providing flexibility and administrative control.
*   **Implementation:** The `Setting` module defines an Eloquent model (`Setting`) to store application configuration parameters in the database. This allows certain settings to be managed dynamically through a user interface rather than solely through static configuration files. A basic administrative Livewire component provides a simple CRUD interface for viewing and updating these settings, ensuring that critical parameters can be adjusted without code changes.

### 7. Status Services: Generic Status Management (`Status` module)
*   **Scope:** Implements a generic and flexible status management service, encapsulated within a dedicated `Status` module, leveraging the `spatie/laravel-model-status` package. This service handles various status mechanisms across different entities within the application (e.g., user status, internship registration status). Key design considerations include:
    *   Support for polymorphic relationships, allowing any Eloquent model to have associated statuses.
    *   Provides standardized methods for defining, assigning, updating, and querying statuses.
    This module ensures consistency and reusability for status workflows across Internara by utilizing a well-maintained external library.
*   **Implementation:** The `Status` module integrates `spatie/laravel-model-status` by providing base implementations or extensions that can be readily adopted by other domain modules. Any Eloquent model requiring status management simply needs to use the `HasStatuses` trait provided by the package. The module also defines conventions for status naming (e.g., `user.active`, `internship.pending`) and provides helper functions or services to interact with the status system, ensuring consistent application of status logic across different entities.

### 8. User Management: Foundational User Model and Basic Operations (`User` module)
*   **Scope:** Establishes the foundational aspects of user management. This encompasses:
    *   Defining the `User` Eloquent model with UUIDs as primary keys to enhance security against resource enumeration attacks.
    *   Core service layer functionalities for basic user creation and retrieval.
    *   Minimal UI integration points to demonstrate user listing.
    Full CRUD operations and advanced user administration features will be expanded in subsequent versions, focusing initially on the essential data model and underlying service interactions.
*   **Implementation:** The `User` module defines the `User` Eloquent model, utilizing UUIDs for its primary key as a security best practice. A `UserService` (within the `User` module's `src/Services` directory) encapsulates core business logic for user creation and basic data retrieval. For the alpha release, simple Livewire components are included to demonstrate listing users, focusing on presenting the foundational data rather than comprehensive administrative features.

### 9. Permission and Role Management: Access Control (`Permission` module)
*   **Scope:** Integrates and customizes the `spatie/laravel-permission` package within a dedicated `Permission` module. This covers:
    *   Initial definition of granular permissions (`module.action` convention) and foundational application-wide roles.
    *   Basic assignment of permissions to roles for core functionalities.
    *   Implementation of authorization checks using Laravel Policies and Gates for critical areas.
    Configurable ID types (UUID/Integer) for permission models will be supported. The alpha scope focuses on establishing the core access control mechanism, with UI for full management deferred.
*   **Implementation:** The `Permission` module wraps and configures the `spatie/laravel-permission` package. It defines a standard convention for permission naming (e.g., `dashboard.view`, `user.create`). Core roles (e.g., 'admin', 'user') are defined, and an initial set of permissions is assigned. Laravel Policies and Gates are used to enforce these permissions in controllers, services, and Blade views, ensuring fine-grained access control. The module ensures compatibility with UUIDs for permission models, aligning with Internara's data strategy.

### 10. User Authentication and Authorization: Secure Access (`Auth` module)
*   **Scope:** Implements standard user authentication processes. This includes:
    *   Core login and logout functionalities.
    *   Basic user registration (if applicable for alpha).
    *   Initial integration with the `Permission` module for foundational authorization checks.
    This module leverages Laravel's built-in authentication features to ensure security and reliability, forming the initial gateway to application access.
*   **Implementation:** The `Auth` module leverages Laravel Fortify or a custom authentication scaffold to provide secure login and logout endpoints and views. User registration, if enabled, is basic. Authorization checks are integrated at key points, primarily using Laravel's built-in authentication guards and by checking against the `Permission` module's defined roles and permissions. This module focuses on establishing a secure entry point to the application.

### 11. Owner Services: Super-Admin Account Protection (`User` module)
*   **Scope:** Defines and protects the special "Owner" role, which represents a super-admin account. This includes:
    *   **Owner Registration:** Implements a dedicated process for the initial registration and setup of the primary owner account, ensuring it's a one-time operation.
    *   Ensuring the owner account cannot be accidentally deleted or have its role changed.
    *   Implementing implicit "grant all" authority for the owner via Laravel Gates.
    This feature is crucial for maintaining ultimate administrative control and system integrity, safeguarding the application's core management.
*   **Implementation:** The "Owner" role is a special role within the `User` module. A dedicated command or registration flow (part of the `Setup` module's initial configuration) ensures that only one "Owner" account can be created. This account is protected from accidental deletion or role changes through application logic (e.g., in a `UserService` or `UserPolicy`). A Laravel Gate is defined to implicitly grant all permissions to any user assigned the "Owner" role, providing super-administrative privileges.

### 12. School Profile and Configuration: Basic Institutional Data (`School` module)
*   **Scope:** Develops foundational features for managing basic school-specific profiles. This module enables:
    *   Defining core school details (e.g., name, primary address, contact information) at a data model and service layer level.
    *   Initial configuration settings related to the school, primarily through environment variables or basic administrative setup.
    Advanced configuration, comprehensive UI for settings management, and features for multi-school institutional management will be built upon this foundation in future releases.
*   **Implementation:** The `School` module defines the `School` Eloquent model to store essential institutional data. A corresponding `SchoolService` handles the business logic for creating and retrieving this basic profile information. For the alpha release, interaction with this data is primarily through the service layer, with minimal UI elements focused on displaying the core details. More complex configuration settings are initially managed via `.env` variables or a very basic administrative form.

### 13. Departments Management: Academic/Organizational Structure (`Department` module)
*   **Scope:** Implements foundational CRUD operations for managing academic or organizational departments within a school. This includes:
    *   Defining the `Department` Eloquent model.
    *   Associated services for core business logic.
    *   Basic UI components for creating, listing, updating, and deleting department entries.
    This module provides the necessary tools for organizing the initial institutional hierarchy and associated data.
*   **Implementation:** The `Department` module introduces the `Department` Eloquent model and a `DepartmentService` to manage its lifecycle. Basic Livewire components are provided to perform CRUD operations (create, read, update, delete) on department records, allowing administrators to establish the initial organizational structure of schools. This module lays the groundwork for associating users and internships with specific departments.

### 14. Internship Management: Foundational Models and Initial Lifecycle (`Internship` module)
*   **Scope:** Develops the foundational core functionalities for managing internship programs. This will include:
    *   Defining essential internship-related models (e.g., `Internship`, `InternshipPeriod`, `InternshipType`).
    *   Basic CRUD operations for creating, listing, and viewing initial internship opportunities.
    *   Conceptual outline for student assignment or application processes, with implementation deferred.
    The alpha scope focuses on establishing the core data structures and minimal interactions required to represent internship programs, paving the way for more complex workflows in later versions.
*   **Implementation:** The `Internship` module defines the core Eloquent models: `Internship`, `InternshipPeriod`, and `InternshipType`. An `InternshipService` handles the business logic for creating, listing, and viewing internship opportunities. Simple Livewire components provide basic CRUD capabilities for these models, focusing on data entry and display. Student assignment or application processes are acknowledged conceptually but their full implementation, including complex workflows and UI, is deferred to future releases.

### 15. System and User Notifications: Basic Communication Channels (`Notification` module)
*   **Scope:** Implements a basic notification system, allowing the application to send system-generated notifications to users. This will encompass:
    *   Initial integration with Laravel's notification features (e.g., mail notifications).
    *   Defining core notification types and templates for essential system events.
    This module provides foundational communication channels within the application, with advanced notification features and user preferences to be developed incrementally.
*   **Implementation:** The `Notification` module leverages Laravel's built-in notification system. It defines custom notification classes for essential system events (e.g., welcome emails, status updates) and registers them. These notifications can be sent via various channels (e.g., mail, database) configured in Laravel. Basic Blade templates are provided for rendering email notifications. The module focuses on ensuring that core system communications are functional, leaving advanced features like in-app notifications or user-configurable preferences for later iterations.

### 16. System Monitor and User Activity Log: Auditing and Debugging (`Log` module)
*   **Scope:** Develops a robust logging system to monitor system events and user activities, primarily utilizing the `spatie/laravel-activitylog` package. This includes:
    *   Tracking important actions performed by users (e.g., login, record changes) for auditing purposes.
    *   Logging system errors and warnings to aid in debugging and stability monitoring.
    This module provides a foundational layer for auditing, debugging, and understanding application usage, enhancing system transparency and accountability. A detailed guide for its integration can be found in the **[Spatie Laravel Activitylog Integration](main/packages/spatie-laravel-activitylog.md)** documentation.
*   **Implementation:** The `Log` module integrates the `spatie/laravel-activitylog` package. It configures the package to automatically log various actions performed on key Eloquent models across the application (e.g., creation, updates, deletions of users, internships, etc.). Custom log events can also be defined and dispatched from services. This provides an auditable trail of user activity. Additionally, standard Laravel logging (via `monolog`) is configured for system errors and warnings, ensuring comprehensive monitoring of application health and behavior.